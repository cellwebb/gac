# Publishes your package to PyPI using Astral/uv for builds.
# Set PYPI_API_TOKEN in repo secrets.

permissions:
  contents: write # Allows writing to the repository

name: Build and Publish to PyPI

on:
  push:
    branches:
      - main

jobs:
  build-publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Allows writing to the repository
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for version bumping

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install uv, build, and twine
        run: pip install uv build twine

      - name: Setup uv virtual environment
        run: uv venv

      - name: Check for version bump and skip flags
        id: version_check
        run: |
          # Install bump-my-version and packaging for version comparison
          pip install bump-my-version packaging

          # Sync versions between __version__.py and .bumpversion.cfg
          python3 << 'EOF'
          import re
          from packaging import version

          # Read version from __version__.py
          try:
              with open('src/gac/__version__.py', 'r') as f:
                  content = f.read()
                  match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
                  version_py = match.group(1) if match else "0.0.0"
          except FileNotFoundError:
              version_py = "0.0.0"

          # Read version from .bumpversion.cfg
          try:
              with open('.bumpversion.cfg', 'r') as f:
                  content = f.read()
                  match = re.search(r'current_version\s*=\s*([^\n]+)', content)
                  version_cfg = match.group(1).strip() if match else "0.0.0"
          except FileNotFoundError:
              version_cfg = "0.0.0"

          print(f"Version in __version__.py: {version_py}")
          print(f"Version in .bumpversion.cfg: {version_cfg}")

          # Compare and use the higher version
          if version.parse(version_py) > version.parse(version_cfg):
              print(f"Using higher version from __version__.py: {version_py}")
              higher_version = version_py
              needs_sync = True
          elif version.parse(version_cfg) > version.parse(version_py):
              print(f"Using higher version from .bumpversion.cfg: {version_cfg}")
              higher_version = version_cfg
              needs_sync = True
          else:
              print(f"Versions are equal: {version_py}")
              higher_version = version_py
              needs_sync = False

          # Write the results for bash to read
          with open('/tmp/sync_info.txt', 'w') as f:
              f.write(f"{higher_version}\n{needs_sync}")
          EOF

          # Read the sync info
          SYNC_INFO=$(cat /tmp/sync_info.txt)
          CURRENT_VERSION=$(echo "$SYNC_INFO" | head -n1)
          NEEDS_SYNC=$(echo "$SYNC_INFO" | tail -n1)

          echo "Synchronized version: $CURRENT_VERSION"

          # If versions were out of sync, update both files
          if [ "$NEEDS_SYNC" = "True" ]; then
            echo "Syncing version files to $CURRENT_VERSION"
            
            # Update .bumpversion.cfg
            if [ ! -f .bumpversion.cfg ]; then
              echo '[bumpversion]' > .bumpversion.cfg
              echo "current_version = $CURRENT_VERSION" >> .bumpversion.cfg
              echo 'commit = False' >> .bumpversion.cfg
              echo 'tag = False' >> .bumpversion.cfg
              echo '' >> .bumpversion.cfg
              echo '[bumpversion:file:src/gac/__version__.py]' >> .bumpversion.cfg
            else
              sed -i "s/current_version = .*/current_version = $CURRENT_VERSION/" .bumpversion.cfg
            fi
            
            # Update __version__.py
            echo '"""Version information for gac package."""' > src/gac/__version__.py
            echo "" >> src/gac/__version__.py
            echo "__version__ = \"$CURRENT_VERSION\"" >> src/gac/__version__.py
          fi

          # Check recent commit messages for skip flags
          RECENT_COMMITS=$(git log --oneline -5)
          echo "Recent commits:"
          echo "$RECENT_COMMITS"

          if echo "$RECENT_COMMITS" | grep -qiE '\[(skip-version-bump|skip-auto-bump|no-auto-bump|version-bump-done)\]'; then
            echo "Skip flag detected in recent commit messages"
            echo "skip_auto_bump=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Enhanced version bump detection for squash merges
          python3 << 'EOF'
          import re
          import subprocess
          import sys
          import os
          from packaging import version

          def get_version_from_commit(commit_sha, file_path):
              """Get version from a specific commit."""
              try:
                  result = subprocess.run(
                      ['git', 'show', f'{commit_sha}:{file_path}'],
                      capture_output=True, text=True, check=True
                  )
                  content = result.stdout
                  
                  if 'gac/__version__.py' in file_path:
                      match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
                  else:  # .bumpversion.cfg
                      match = re.search(r'current_version\s*=\s*([^\n]+)', content)
                  
                  return match.group(1).strip() if match else "0.0.0"
              except (subprocess.CalledProcessError, AttributeError):
                  return "0.0.0"

          def get_current_version():
              """Get current version from __version__.py"""
              try:
                  with open('src/gac/__version__.py', 'r') as f:
                      content = f.read()
                      match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
                      return match.group(1) if match else "0.0.0"
              except FileNotFoundError:
                  return "0.0.0"

          def get_version_from_parent():
              """Get version from parent commit (HEAD~1)"""
              try:
                  # For squash merges, we want to compare with the previous commit on main
                  result = subprocess.run(['git', 'rev-parse', 'HEAD~1'], 
                                        capture_output=True, text=True, check=True)
                  parent_sha = result.stdout.strip()
                  return get_version_from_commit(parent_sha, 'src/gac/__version__.py'), parent_sha
              except subprocess.CalledProcessError:
                  return "0.0.0", None

          # Method 1: Compare with parent commit (works for squash merges)
          current_version = get_current_version()
          parent_version, parent_sha = get_version_from_parent()

          print(f"Current version (HEAD): {current_version}")
          print(f"Parent version (HEAD~1): {parent_version}")
          if parent_sha:
              print(f"Parent commit: {parent_sha}")

          # Method 2: Use github.event context if available
          before_sha = os.environ.get('GITHUB_EVENT_BEFORE', '')
          after_sha = os.environ.get('GITHUB_EVENT_AFTER', '')

          if before_sha and before_sha != "0000000000000000000000000000000000000000":
              github_before_version = get_version_from_commit(before_sha, 'src/gac/__version__.py')
              print(f"GitHub event before version: {github_before_version}")
              
              # Use GitHub event version if it's different from parent
              if github_before_version != "0.0.0":
                  parent_version = github_before_version

          # Method 3: Check git diff for version file changes in recent commits
          try:
              # Check if version file was modified in the last commit
              result = subprocess.run(
                  ['git', 'diff', 'HEAD~1', 'HEAD', '--name-only'],
                  capture_output=True, text=True, check=True
              )
              changed_files = result.stdout.strip().split('\n')
              version_file_changed = any('__version__.py' in f or '.bumpversion.cfg' in f for f in changed_files)
              print(f"Version files changed in last commit: {version_file_changed}")
              print(f"Changed files: {changed_files}")
          except subprocess.CalledProcessError:
              version_file_changed = False

          # Compare versions
          skip_auto_bump = False
          try:
              if version.parse(current_version) > version.parse(parent_version):
                  print(f"[OK] Version was manually bumped: {parent_version} -> {current_version}")
                  skip_auto_bump = True
              elif version_file_changed and current_version == parent_version:
                  print(" Version file was modified but version unchanged - assuming intentional")
                  skip_auto_bump = True
              else:
                  print(f"[OK] No version bump detected, auto-bump will proceed")
                  skip_auto_bump = False
          except Exception as e:
              print(f"Error comparing versions: {e}")
              print("Proceeding with auto-bump to be safe")
              skip_auto_bump = False

          # Output result for GitHub Actions
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"skip_auto_bump={str(skip_auto_bump).lower()}\n")
              f.write(f"current_version={current_version}\n")
              f.write(f"parent_version={parent_version}\n")

          if skip_auto_bump:
              print(" Skipping auto-bump - version was already updated")
              sys.exit(0)
          else:
              print(" Proceeding with auto-bump")
              sys.exit(1)
          EOF

      - name: Apply automatic version bump
        if: steps.version_check.outputs.skip_auto_bump != 'true'
        run: |
          echo "Applying automatic version bump..."
          bump-my-version bump patch --allow-dirty

      - name: Build package
        run: |
          uv build

      - name: Publish to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: uv run twine upload dist/*

      - name: Push version bump to GitHub
        if: ${{ success() }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add .
          git commit -m "chore: bump version [ci skip]" || echo "No changes to commit"
          git push
