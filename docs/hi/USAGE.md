# gac कमांड-लाइन उपयोग

[English](../en/USAGE.md) | [简体中文](../zh-CN/USAGE.md) | [繁體中文](../zh-TW/USAGE.md) | [日本語](../ja/USAGE.md) | [한국어](../ko/USAGE.md) | **हिन्दी** | [Tiếng Việt](../vi/USAGE.md) | [Français](../fr/USAGE.md) | [Русский](../ru/USAGE.md) | [Español](../es/USAGE.md) | [Português](../pt/USAGE.md) | [Norsk](../no/USAGE.md) | [Svenska](../sv/USAGE.md) | [Deutsch](../de/USAGE.md) | [Nederlands](../nl/USAGE.md) | [Italiano](../it/USAGE.md)

यह दस्तावेज़ `gac` CLI टूल के लिए सभी उपलब्ध फ्लैग और विकल्पों का वर्णन करता है।

## विषय-सूची

- [gac कमांड-लाइन उपयोग](#gac-कमांड-लाइन-उपयोग)
  - [विषय-सूची](#विषय-सूची)
  - [बेसिक उपयोग](#बेसिक-उपयोग)
  - [कोर वर्कफ़्लो फ्लैग](#कोर-वर्कफ़्लो-फ्लैग)
  - [मैसेज कस्टमाइज़ेशन](#मैसेज-कस्टमाइज़ेशन)
  - [आउटपुट और वर्बोसिटी](#आउटपुट-और-वर्बोसिटी)
  - [हेल्प और वर्जन](#हेल्प-और-वर्जन)
  - [उदाहरण वर्कफ़्लो](#उदाहरण-वर्कफ़्लो)
  - [एडवांस्ड](#एडवांस्ड)
    - [प्री-कमिट और लेफ्थुक हुक को छोड़ना](#प्री-कमिट-और-लेफ्थुक-हुक-को-छोड़ना)
    - [सिक्योरिटी स्कैनिंग](#सिक्योरिटी-स्कैनिंग)
    - [SSL प्रमाणपत्र सत्यापन](#ssl-प्रमाणपत्र-सत्यापन)
  - [कॉन्फ़िगरेशन नोट्स](#कॉन्फ़िगरेशन-नोट्स)
    - [एडवांस्ड कॉन्फ़िगरेशन विकल्प](#एडवांस्ड-कॉन्फ़िगरेशन-विकल्प)
    - [कॉन्फ़िगरेशन सबकमांड्स](#कॉन्फ़िगरेशन-सबकमांड्स)
  - [इंटरैक्टिव मोड](#इंटरैक्टिव-मोड)
    - [यह कैसे काम करता है](#यह-कैसे-काम-करता-है)
    - [इंटरैक्टिव मोड का उपयोग कब करें](#इंटरैक्टिव-मोड-का-उपयोग-कब-करें)
    - [उपयोग के उदाहरण](#उपयोग-के-उदाहरण)
    - [प्रश्न-उत्तर वर्कफ़्लो](#प्रश्न-उत्तर-वर्कफ़्लो)
    - [अन्य फ्लैग के साथ संयोजन](#अन्य-फ्लैग-के-साथ-संयोजन)
    - [सर्वोत्तम प्रथाएं](#सर्वोत्तम-प्रथाएं)
  - [मदद प्राप्त करना](#मदद-प्राप्त-करना)

## बेसिक उपयोग

```sh
gac init
# फिर अपने प्रोवाइडर, मॉडल और API कुंजियों को इंटरैक्टिव रूप से कॉन्फ़िगर करने के लिए प्रॉम्प्ट का पालन करें
gac
```

स्टेज्ड परिवर्तनों के लिए एक LLM-संचालित कमिट मैसेज जेनरेट करता है और पुष्टि के लिए प्रॉम्प्ट करता है। पुष्टि प्रॉम्प्ट निम्नलिखित स्वीकार करता है:

- `y` या `yes` - कमिट के साथ आगे बढ़ें
- `n` या `no` - कमिट रद्द करें
- `r` या `reroll` - समान संदर्भ के साथ कमिट मैसेज पुनर्जनरेट करें
- `e` या `edit` - रिच टर्मिनल एडिटिंग के साथ कमिट मैसेज को इन-प्लेस एडिट करें (vi/emacs कीबाइंडिंग्स)
- कोई भी अन्य टेक्स्ट - उस टेक्स्ट को फीडबैक के रूप में पुनर्जनरेट करें (जैसे, `make it shorter`, `focus on performance`)
- खाली इनपुट (सिर्फ Enter) - प्रॉम्प्ट फिर से दिखाएं

---

## कोर वर्कफ़्लो फ्लैग

| फ्लैग / विकल्प       | शॉर्ट | विवरण                                                            |
| -------------------- | ----- | ---------------------------------------------------------------- |
| `--add-all`          | `-a`  | कमिट करने से पहले सभी परिवर्तनों को स्टेज करें                   |
| `--group`            | `-g`  | स्टेज्ड परिवर्तनों को कई तार्किक कमिट्स में ग्रुप करें           |
| `--push`             | `-p`  | कमिट करने के बाद परिवर्तनों को रिमोट पर पुश करें                 |
| `--yes`              | `-y`  | बिना प्रॉम्प्ट किए स्वचालित रूप से कमिट की पुष्टि करें           |
| `--dry-run`          |       | बिना कोई परिवर्तन किए होने वाला दिखाएं                           |
| `--message-only`     |       | केवल जेनरेटेड कमिट मैसेज आउटपुट करें, कोई वास्तविक कमिट न करें   |
| `--no-verify`        |       | कमिट करते समय प्री-कमिट और लेफ्थुक हुक छोड़ें                    |
| `--skip-secret-scan` |       | स्टेज्ड परिवर्तनों में सीक्रेट्स के लिए सिक्योरिटी स्कैन छोड़ें  |
| `--no-verify-ssl`    |       | SSL प्रमाणपत्र सत्यापन छोड़ें (कॉर्पोरेट प्रॉक्सी के लिए उपयोगी) |
| `--interactive`      | `-i`  | बेहतर कमिट बनाने के लिए परिवर्तनों के बारे में प्रश्न पूछें      |

**नोट:** सभी परिवर्तनों को पहले स्टेज करने के लिए `-a` और `-g` को जोड़ें (यानी, `-ag`), फिर उन्हें कमिट्स में ग्रुप करें।

**नोट:** `--group` का उपयोग करते समय, अधिकतम आउटपुट टोकन सीमा कमिट की जा रही फाइलों की संख्या के आधार पर स्वचालित रूप से स्केल की जाती है (1-9 फाइलों के लिए 2x, 10-19 फाइलों के लिए 3x, 20-29 फाइलों के लिए 4x, 30+ फाइलों के लिए 5x)। यह सुनिश्चित करता है कि LLM के पास सभी ग्रुप्ड कमिट्स को बिना कटौती के जेनरेट करने के लिए पर्याप्त टोकन हों, यहां तक कि बड़े चेंजसेट के लिए भी।

**नोट:** `--message-only` और `--group` एक साथ उपयोग नहीं किए जा सकते। बाहरी प्रोसेसिंग के लिए कमिट मैसेज चाहिए हो तो `--message-only` का उपयोग करें, और वर्तमान git वर्कफ़्लो में कई कमिट व्यवस्थित करने के लिए `--group` का उपयोग करें।

**नोट:** `--interactive` फ्लैग आपके परिवर्तनों के बारे में प्रश्न पूछकर LLM को अतिरिक्त संदर्भ प्रदान करता है, जिससे अधिक सटीक और विस्तृत कमिट मैसेज मिलते हैं। यह विशेष रूप से जटिल परिवर्तनों के लिए उपयोगी है या जब आप सुनिश्चित करना चाहते हैं कि कमिट मैसेज आपके काम के पूरे संदर्भ को कैप्चर करे।

## मैसेज कस्टमाइज़ेशन

| फ्लैग / विकल्प      | शॉर्ट | विवरण                                                                   |
| ------------------- | ----- | ----------------------------------------------------------------------- |
| `--one-liner`       | `-o`  | एक लाइन का कमिट मैसेज जेनरेट करें                                       |
| `--verbose`         | `-v`  | प्रेरणा, आर्किटेक्चर, और इम्पैक्ट के साथ विस्तृत कमिट मैसेज जेनरेट करें |
| `--hint <text>`     | `-h`  | LLM को मार्गदर्शन देने के लिए एक हिंट जोड़ें                            |
| `--model <model>`   | `-m`  | इस कमिट के लिए उपयोग करने के लिए मॉडल निर्दिष्ट करें                    |
| `--language <lang>` | `-l`  | भाषा को ओवरराइड करें (नाम या कोड: 'Spanish', 'es', 'zh-CN', 'ja')       |
| `--scope`           | `-s`  | कमिट के लिए उपयुक्त स्कोप अनुमान लगाएं                                  |

**नोट:** आप पुष्टि प्रॉम्प्ट पर सिर्फ टाइपिंग करके इंटरैक्टिव रूप से फीडबैक प्रदान कर सकते हैं - 'r' के साथ प्रीफिक्स करने की आवश्यकता नहीं है। सिंपल रीरोल के लिए `r` टाइप करें, vi/emacs कीबाइंडिंग्स के साथ इन-प्लेस एडिट करने के लिए `e` टाइप करें, या `make it shorter` की तरह सीधे अपना फीडबैक टाइप करें।

## आउटपुट और वर्बोसिटी

| फ्लैग / विकल्प        | शॉर्ट | विवरण                                                               |
| --------------------- | ----- | ------------------------------------------------------------------- |
| `--quiet`             | `-q`  | गलतियों को छोड़कर सभी आउटपुट को दबाएं                               |
| `--log-level <level>` |       | लॉग स्तर सेट करें (debug, info, warning, error)                     |
| `--show-prompt`       |       | कमिट मैसेज जेनरेशन के लिए उपयोग किए गए LLM प्रॉम्प्ट को प्रिंट करें |

## हेल्प और वर्जन

| फ्लैग / विकल्प | शॉर्ट | विवरण                             |
| -------------- | ----- | --------------------------------- |
| `--version`    |       | gac वर्जन दिखाएं और बाहर निकलें   |
| `--help`       |       | हेल्प मैसेज दिखाएं और बाहर निकलें |

---

## उदाहरण वर्कफ़्लो

- **सभी परिवर्तनों को स्टेज करें और कमिट करें:**

  ```sh
  gac -a
  ```

- **एक कदम में कमिट और पुश करें:**

  ```sh
  gac -ap
  ```

- **एक लाइन का कमिट मैसेज जेनरेट करें:**

  ```sh
  gac -o
  ```

- **संरचित सेक्शन के साथ विस्तृत कमिट मैसेज जेनरेट करें:**

  ```sh
  gac -v
  ```

- **LLM के लिए एक हिंट जोड़ें:**

  ```sh
  gac -h "Refactor authentication logic"
  ```

- **कमिट के लिए स्कोप अनुमान लगाएं:**

  ```sh
  gac -s
  ```

- **स्टेज्ड परिवर्तनों को तार्किक कमिट्स में ग्रुप करें:**

  ```sh
  gac -g
  # केवल उन फाइलों को ग्रुप करता है जिन्हें आपने पहले से स्टेज किया है
  ```

- **सभी परिवर्तनों को ग्रुप करें (स्टेज्ड + अनस्टेज्ड) और ऑटो-कन्फर्म करें:**

  ```sh
  gac -agy
  # सब कुछ स्टेज करता है, इसे ग्रुप करता है, और ऑटो-कन्फर्म करता है
  ```

- **इस कमिट के लिए एक विशिष्ट मॉडल का उपयोग करें:**

  ```sh
  gac -m anthropic:claude-haiku-4-5
  ```

- **एक विशिष्ट भाषा में कमिट मैसेज जेनरेट करें:**

  ```sh
  # भाषा कोड का उपयोग करके (छोटा)
  gac -l zh-CN
  gac -l ja
  gac -l es

  # पूरे नामों का उपयोग करके
  gac -l "Simplified Chinese"
  gac -l Japanese
  gac -l Spanish
  ```

- **ड्राई रन (देखें कि क्या होगा):**

  ```sh
  gac --dry-run
  ```

- **केवल कमिट मैसेज प्राप्त करें (स्क्रिप्ट इंटीग्रेशन के लिए):**

  ```sh
  gac --message-only
  # उदाहरण आउटपुट: feat: add user authentication system
  ```

- **एक-लाइनर फ़ॉर्मेट में कमिट मैसेज प्राप्त करें:**

  ```sh
  gac --message-only --one-liner
  # उदाहरण आउटपुट: feat: add user authentication system
  ```

- **संदर्भ प्रदान करने के लिए इंटरैक्टिव मोड का उपयोग करें:**

  ```sh
  gac -i
  # इन परिवर्तनों का मुख्य उद्देश्य क्या है?
  # आप कौन सी समस्या हल कर रहे हैं?
  # क्या उल्लेख करने लायक कोई इम्प्लीमेंटेशन डिटेल्स हैं?
  ```

- **विस्तृत आउटपुट के साथ इंटरैक्टिव मोड:**

  ```sh
  gac -i -v
  # प्रश्न पूछें और विस्तृत कमिट मैसेज जेनरेट करें
  ```

## एडवांस्ड

- अधिक शक्तिशाली वर्कफ़्लो के लिए फ्लैग को जोड़ें (उदाहरण के लिए, `gac -ayp` स्टेज करने, ऑटो-कन्फर्म करने और पुश करने के लिए)
- LLM को भेजे गए प्रॉम्प्ट को डीबग या समीक्षा करने के लिए `--show-prompt` का उपयोग करें
- `--log-level` या `--quiet` के साथ वर्बोसिटी को एडजस्ट करें

### प्री-कमिट और लेफ्थुक हुक को छोड़ना

`--no-verify` फ्लैग आपको अपने प्रोजेक्ट में कॉन्फ़िगर किए गए किसी भी प्री-कमिट या लेफ्थुक हुक को छोड़ने की अनुमति देता है:

```sh
gac --no-verify  # सभी प्री-कमिट और लेफ्थुक हुक छोड़ें
```

**`--no-verify` का उपयोग कब करें:**

- प्री-कमिट या लेफ्थुक हुक अस्थायी रूप से विफल हो रहे हों
- समय लेने वाले हुक के साथ काम करते समय
- अभी तक सभी जांचों को पास न करने वाले काम-प्रगति कोड को कमिट करते समय

**नोट:** सावधानी से उपयोग करें क्योंकि ये हुक कोड गुणवत्ता मानकों को बनाए रखते हैं।

### सिक्योरिटी स्कैनिंग

gac में बिल्ट-इन सिक्योरिटी स्कैनिंग शामिल है जो स्वचालित रूप से आपके स्टेज्ड परिवर्तनों में संभावित सीक्रेट्स और API कुंजियों का पता लगाती है। यह गलती से संवेदनशील जानकारी कमिट करने से रोकने में मदद करता है।

**सिक्योरिटी स्कैन छोड़ना:**

```sh
gac --skip-secret-scan  # इस कमिट के लिए सिक्योरिटी स्कैन छोड़ें
```

**स्थायी रूप से अक्षम करने के लिए:** अपनी `.gac.env` फाइल में `GAC_SKIP_SECRET_SCAN=true` सेट करें।

**कब छोड़ें:**

- प्लेसहोल्डर कुंजियों के साथ उदाहरण कोड कमिट करते समय
- डमी क्रेडेंशियल्स वाले टेस्ट फिक्स्चर के साथ काम करते समय
- जब आपने सत्यापित कर लिया है कि परिवर्तन सुरक्षित हैं

**नोट:** स्कैनर सामान्य सीक्रेट फॉर्मेट का पता लगाने के लिए पैटर्न मिलान का उपयोग करता है। कमिट करने से पहले हमेशा अपने स्टेज्ड परिवर्तनों की समीक्षा करें।

### SSL प्रमाणपत्र सत्यापन

`--no-verify-ssl` फ्लैग आपको API कॉल के लिए SSL प्रमाणपत्र सत्यापन छोड़ने की अनुमति देता है:

```sh
gac --no-verify-ssl  # इस कमिट के लिए SSL सत्यापन छोड़ें
```

**स्थायी रूप से सेट करने के लिए:** अपनी `.gac.env` फाइल में `GAC_NO_VERIFY_SSL=true` सेट करें।

**`--no-verify-ssl` का उपयोग कब करें:**

- कॉर्पोरेट प्रॉक्सी SSL ट्रैफ़िक को इंटरसेप्ट कर रहे हों (MITM प्रॉक्सी)
- विकास परिवेश स्व-हस्ताक्षरित प्रमाणपत्रों का उपयोग कर रहे हों
- नेटवर्क सुरक्षा सेटिंग्स के कारण SSL प्रमाणपत्र त्रुटियाँ आ रही हों

**नोट:** इस विकल्प का उपयोग केवल विश्वसनीय नेटवर्क वातावरण में करें। SSL सत्यापन को अक्षम करने से सुरक्षा कम हो जाती है और आपके API अनुरोध मैन-इन-द-मिडल हमलों के प्रति संवेदनशील हो सकते हैं।

## कॉन्फ़िगरेशन नोट्स

- gac को सेट अप करने की अनुशंसित विधि `gac init` चलाना और इंटरैक्टिव प्रॉम्प्ट का पालन करना है।
- पहले से कॉन्फ़िगर की गई भाषा है और सिर्फ प्रोवाइडर या मॉडल स्विच करने की जरूरत है? भाषा प्रश्नों के बिना सेटअप दोहराने के लिए `gac model` चलाएं।
- **Claude Code का उपयोग कर रहे हैं?** OAuth प्रमाणीकरण निर्देशों के लिए [Claude Code सेटअप गाइड](CLAUDE_CODE.md) देखें।
- **क्या आप Qwen.ai का उपयोग कर रहे हैं?** OAuth प्रमाणीकरण निर्देशों के लिए [Qwen.ai सेटअप गाइड](QWEN.md) देखें।
- gac निम्नलिखित प्राथमिकता के क्रम में कॉन्फ़िगरेशन लोड करता है:
  1. CLI फ्लैग
  2. पर्यावरण चर
  3. प्रोजेक्ट-स्तर `.gac.env`
  4. यूज़र-स्तर `~/.gac.env`

### एडवांस्ड कॉन्फ़िगरेशन विकल्प

आप इन वैकल्पिक पर्यावरण चरों के साथ gac के व्यवहार को कस्टमाइज़ कर सकते हैं:

- `GAC_ALWAYS_INCLUDE_SCOPE=true` - कमिट मैसेज में स्वचालित रूप से स्कोप अनुमान लगाएं और शामिल करें (जैसे, `feat(auth):` बनाम `feat:`)
- `GAC_VERBOSE=true` - प्रेरणा, आर्किटेक्चर, और इम्पैक्ट सेक्शन के साथ विस्तृत कमिट मैसेज जेनरेट करें
- `GAC_TEMPERATURE=0.7` - LLM रचनात्मकता को नियंत्रित करें (0.0-1.0, कम = अधिक केंद्रित)
- `GAC_MAX_OUTPUT_TOKENS=4096` - जेनरेट किए गए मैसेज के लिए अधिकतम टोकन (`--group` का उपयोग करते समय फाइल काउंट के आधार पर स्वचालित रूप से 2-5x स्केल किया गया; उच्च या निम्न जाने के लिए ओवरराइड करें)
- `GAC_WARNING_LIMIT_TOKENS=4096` - जब प्रॉम्प्ट इस टोकन काउंट से अधिक हो जाएं तो चेतावनी दें
- `GAC_SYSTEM_PROMPT_PATH=/path/to/custom_prompt.txt` - कमिट मैसेज जेनरेशन के लिए कस्टम सिस्टम प्रॉम्प्ट का उपयोग करें
- `GAC_LANGUAGE=Spanish` - एक विशिष्ट भाषा में कमिट मैसेज जेनरेट करें (जैसे, Spanish, French, Japanese, German)। पूरे नाम या ISO कोड का समर्थन करता है (es, fr, ja, de, zh-CN)। इंटरैक्टिव चयन के लिए `gac language` का उपयोग करें
- `GAC_TRANSLATE_PREFIXES=true` - कन्वेंशनल कमिट प्रीफिक्सेस (feat, fix, आदि) को टारगेट भाषा में अनुवाद करें (डिफ़ॉल्ट: false, प्रीफिक्स को अंग्रेजी में रखता है)
- `GAC_SKIP_SECRET_SCAN=true` - स्टेज्ड परिवर्तनों में सीक्रेट्स के लिए स्वचालित सिक्योरिटी स्कैनिंग अक्षम करें (सावधानी से उपयोग करें)
- `GAC_NO_VERIFY_SSL=true` - API कॉल के लिए SSL प्रमाणपत्र सत्यापन छोड़ें (SSL ट्रैफ़िक को इंटरसेप्ट करने वाले कॉर्पोरेट प्रॉक्सी के लिए उपयोगी)

पूर्ण कॉन्फ़िगरेशन टेम्प्लेट के लिए `.gac.env.example` देखें।

कस्टम सिस्टम प्रॉम्प्ट बनाने पर विस्तृत मार्गदर्शन के लिए, [docs/CUSTOM_SYSTEM_PROMPTS.md](docs/CUSTOM_SYSTEM_PROMPTS.md) देखें।

### कॉन्फ़िगरेशन सबकमांड्स

निम्नलिखित उप-कमांड उपलब्ध हैं:

- `gac init` — प्रदाता, मॉडल और भाषा विन्यास के लिए इंटरैक्टिव सेटअप विज़ार्ड
- `gac model` — भाषा संकेतों के बिना प्रदाता/मॉडल/API कुंजी सेटअप (त्वरित स्विच के लिए आदर्श)
- `gac auth` — सभी प्रदाताओं के लिए OAuth प्रमाणीकरण स्थिति दिखाएं
- `gac auth claude-code login` — OAuth का उपयोग करके Claude Code में लॉगिन करें (ब्राउज़र खोलता है)
- `gac auth claude-code logout` — Claude Code से लॉगआउट करें और संग्रहीत टोकन हटाएं
- `gac auth claude-code status` — Claude Code प्रमाणीकरण स्थिति जांचें
- `gac auth qwen login` — OAuth डिवाइस फ्लो का उपयोग करके Qwen में लॉगिन करें (ब्राउज़र खोलता है)
- `gac auth qwen logout` — Qwen से लॉगआउट करें और संग्रहीत टोकन हटाएं
- `gac auth qwen status` — Qwen प्रमाणीकरण स्थिति जांचें
- `gac config show` — वर्तमान विन्यास दिखाएं
- `gac config set KEY VALUE` — `$HOME/.gac.env` में कॉन्फिग कुंजी सेट करें
- `gac config get KEY` — कॉन्फिग मान प्राप्त करें
- `gac config unset KEY` — `$HOME/.gac.env` से कॉन्फिग कुंजी हटाएं
- `gac language` (या `gac lang`) — कमिट संदेशों के लिए इंटरैक्टिव भाषा चयनकर्ता (GAC_LANGUAGE सेट करता है)
- `gac diff` — स्टेज्ड/अस्टेज्ड परिवर्तनों, रंग और ट्रंकेशन विकल्पों के साथ फ़िल्टर किए गए git diff को दिखाएं

## इंटरैक्टिव मोड

`--interactive` (`-i`) फ्लैग आपके परिवर्तनों के बारे में लक्षित प्रश्न पूछकर gac की कमिट मैसेज जेनरेशन को बेहतर बनाता है। यह अतिरिक्त संदर्भ LLM को अधिक सटीक, विस्तृत और संदर्भ-उपयुक्त कमिट मैसेज बनाने में मदद करता है।

### यह कैसे काम करता है

जब आप `--interactive` का उपयोग करते हैं, तो gac आपसे इस तरह के प्रश्न पूछेगा:

- **इन परिवर्तनों का मुख्य उद्देश्य क्या है?** - उच्च-स्तरीय लक्ष्य को समझने में मदद करता है
- **आप कौन सी समस्या हल कर रहे हैं?** - प्रेरणा पर संदर्भ प्रदान करता है
- **क्या उल्लेख करने लायक कोई इम्प्लीमेंटेशन डिटेल्स हैं?** - तकनीकी विशिष्टताओं को कैप्चर करता है
- **क्या कोई breaking changes हैं?** - संभावित इम्पैक्ट समस्याओं की पहचान करता है
- **क्या यह किसी issue या टिकट से संबंधित है?** - प्रोजेक्ट प्रबंधन से जोड़ता है

### इंटरैक्टिव मोड का उपयोग कब करें

इंटरैक्टिव मोड विशेष रूप से उपयोगी है:

- **जटिल परिवर्तनों** के लिए जहां संदर्भ diff से अकेले स्पष्ट नहीं है
- **रिफैक्टरिंग काम** के लिए जो कई फाइलों और अवधारणाओं में फैला हुआ है
- **नई सुविधाओं** के लिए जिनके लिए समग्र उद्देश्य की व्याख्या की आवश्यकता होती है
- **बग फिक्स** के लिए जहां जड़ का कारण तुरंत दिखाई नहीं देता
- **प्रदर्शन अनुकूलन** के लिए जहां तर्क स्पष्ट नहीं है
- **कोड रिव्यू तैयारी** - प्रश्न आपको अपने परिवर्तनों के बारे में सोचने में मदद करते हैं

### उपयोग के उदाहरण

**बेसिक इंटरैक्टिव मोड:**

```sh
gac -i
```

यह करेगा:

1. आपको स्टेज्ड परिवर्तनों का सारांश दिखाएगा
2. आपसे परिवर्तनों के बारे में प्रश्न पूछेगा
3. आपके उत्तरों को शामिल करके एक कमिट मैसेज जेनरेट करेगा
4. पुष्टि के लिए कहेगा (या `-y` के साथ संयोजित होने पर स्वचालित रूप से पुष्टि करेगा)

**स्टेज्ड परिवर्तनों के साथ इंटरैक्टिव मोड:**

```sh
gac -ai
# सभी परिवर्तनों को स्टेज करें, फिर बेहतर संदर्भ के लिए प्रश्न पूछें
```

**विशिष्ट संकेतों के साथ इंटरैक्टिव मोड:**

```sh
gac -i -h "उपयोगकर्ता प्रोफाइल के लिए डेटाबेस माइग्रेशन"
# LLM को केंद्रित करने के लिए एक विशिष्ट संकेत प्रदान करते समय प्रश्न पूछें
```

**विस्तृत आउटपुट के साथ इंटरैक्टिव मोड:**

```sh
gac -i -v
# प्रश्न पूछें और एक विस्तृत, संरचित कमिट मैसेज जेनरेट करें
```

**स्वचालित रूप से पुष्टि किए गए इंटरैक्टिव मोड:**

```sh
gac -i -y
# प्रश्न पूछें लेकिन परिणामी कमिट को स्वचालित रूप से पुष्टि करें
```

### प्रश्न-उत्तर वर्कफ़्लो

इंटरैक्टिव वर्कफ़्लो इस पैटर्न का अनुसरण करता है:

1. **परिवर्तनों की समीक्षा** - gac दिखाता है कि आप क्या कमिट कर रहे हैं
2. **प्रश्नों के उत्तर दें** - प्रत्येक प्रॉम्प्ट का उत्तर प्रासंगिक विवरणों के साथ करें
3. **संदर्भ वृद्धि** - आपके उत्तर LLM प्रॉम्प्ट में जोड़े जाते हैं
4. **मैसेज जेनरेशन** - LLM पूर्ण संदर्भ के साथ एक कमिट मैसेज बनाता है
5. **पुष्टि** - कमिट की समीक्षा और पुष्टि करें (या `-y` के साथ स्वचालित रूप से पुष्टि करें)

**उपयोगी उत्तर प्रदान करने के लिए टिप्स:**

- **संक्षिप्त लेकिन व्यापक** - बहुत अधिक शब्दावली के बिना मुख्य विवरण प्रदान करें
- **"क्यों" पर ध्यान केंद्रित करें** - अपने परिवर्तनों के पीछे तर्क समझाएं
- **बाधाओं का उल्लेख करें** - कोई सीमाएं या विशेष विचार नोट करें
- **बाहरी संदर्भ से जोड़ें** - issues, दस्तावेज़ीकरण, या डिज़ाइन दस्तावेज़ों का संदर्भ दें
- **खाली उत्तर ठीक हैं** - यदि कोई प्रश्न लागू नहीं होता है, तो सिर्फ Enter दबाएं

### अन्य फ्लैग के साथ संयोजन

इंटरैक्टिव मोड अधिकांश अन्य फ्लैग के साथ अच्छी तरह काम करता है:

```sh
# सभी परिवर्तनों को स्टेज करें और प्रश्न पूछें
gac -ai

# विस्तृत आउटपुट के साथ प्रश्न पूछें
gac -i -v
```

### सर्वोत्तम प्रथाएं

- **जटिल PRs के लिए उपयोग करें** - विशेष रूप से उपयोगी जो pull requests को विस्तृत विवरण की आवश्यकता होती है
- **टीम सहयोग** - प्रश्न आपको उन परिवर्तनों के बारे में सोचने में मदद करते हैं जिन्हें अन्य लोग समीक्षा करेंगे
- **दस्तावेज़ीकरण तैयारी** - आपके उत्तर release notes के आधार का निर्माण करने में मदद कर सकते हैं
- **सीखने का उपकरण** - प्रश्न कमिट मैसेज की अच्छी प्रथाओं को मजबूत करते हैं
- **सरल परिवर्तनों के लिए छोड़ें** - तुच्छ फिक्स के लिए, बेसिक मोड तेज हो सकता है

## मदद प्राप्त करना

- कस्टम सिस्टम प्रॉम्प्ट के लिए, [docs/CUSTOM_SYSTEM_PROMPTS.md](docs/CUSTOM_SYSTEM_PROMPTS.md) देखें
- ट्रबलशूटिंग और एडवांस्ड टिप्स के लिए, [docs/TROUBLESHOOTING.md](docs/TROUBLESHOOTING.md) देखें
- इंस्टॉलेशन और कॉन्फ़िगरेशन के लिए, [README.md#installation-and-configuration](README.md#installation-and-configuration) देखें
- योगदान करने के लिए, [docs/CONTRIBUTING.md](docs/CONTRIBUTING.md) देखें
- लाइसेंस जानकारी: [LICENSE](LICENSE)
