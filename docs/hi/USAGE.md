# gac कमांड-लाइन उपयोग

[English](../en/USAGE.md) | [简体中文](../zh-CN/USAGE.md) | [繁體中文](../zh-TW/USAGE.md) | [日本語](../ja/USAGE.md) | [한국어](../ko/USAGE.md) | **हिन्दी** | [Tiếng Việt](../vi/USAGE.md) | [Français](../fr/USAGE.md) | [Русский](../ru/USAGE.md) | [Español](../es/USAGE.md) | [Português](../pt/USAGE.md) | [Norsk](../no/USAGE.md) | [Svenska](../sv/USAGE.md) | [Deutsch](../de/USAGE.md) | [Nederlands](../nl/USAGE.md) | [Italiano](../it/USAGE.md)

यह दस्तावेज़ `gac` CLI टूल के लिए सभी उपलब्ध फ्लैग और विकल्पों का वर्णन करता है।

## विषय-सूची

- [gac कमांड-लाइन उपयोग](#gac-कमांड-लाइन-उपयोग)
  - [विषय-सूची](#विषय-सूची)
  - [बेसिक उपयोग](#बेसिक-उपयोग)
  - [कोर वर्कफ़्लो फ्लैग](#कोर-वर्कफ़्लो-फ्लैग)
  - [मैसेज कस्टमाइज़ेशन](#मैसेज-कस्टमाइज़ेशन)
  - [आउटपुट और वर्बोसिटी](#आउटपुट-और-वर्बोसिटी)
  - [हेल्प और वर्जन](#हेल्प-और-वर्जन)
  - [उदाहरण वर्कफ़्लो](#उदाहरण-वर्कफ़्लो)
  - [एडवांस्ड](#एडवांस्ड)
    - [प्री-कमिट और लेफ्थुक हुक को छोड़ना](#प्री-कमिट-और-लेफ्थुक-हुक-को-छोड़ना)
  - [कॉन्फ़िगरेशन नोट्स](#कॉन्फ़िगरेशन-नोट्स)
    - [एडवांस्ड कॉन्फ़िगरेशन विकल्प](#एडवांस्ड-कॉन्फ़िगरेशन-विकल्प)
    - [कॉन्फ़िगरेशन सबकमांड्स](#कॉन्फ़िगरेशन-सबकमांड्स)
  - [मदद प्राप्त करना](#मदद-प्राप्त-करना)

## बेसिक उपयोग

```sh
gac init
# फिर अपने प्रोवाइडर, मॉडल और API कुंजियों को इंटरैक्टिव रूप से कॉन्फ़िगर करने के लिए प्रॉम्प्ट का पालन करें
gac
```

स्टेज्ड परिवर्तनों के लिए एक LLM-संचालित कमिट मैसेज जेनरेट करता है और पुष्टि के लिए प्रॉम्प्ट करता है। पुष्टि प्रॉम्प्ट निम्नलिखित स्वीकार करता है:

- `y` या `yes` - कमिट के साथ आगे बढ़ें
- `n` या `no` - कमिट रद्द करें
- `r` या `reroll` - समान संदर्भ के साथ कमिट मैसेज पुनर्जनरेट करें
- `e` या `edit` - रिच टर्मिनल एडिटिंग के साथ कमिट मैसेज को इन-प्लेस एडिट करें (vi/emacs कीबाइंडिंग्स)
- कोई भी अन्य टेक्स्ट - उस टेक्स्ट को फीडबैक के रूप में पुनर्जनरेट करें (जैसे, `make it shorter`, `focus on performance`)
- खाली इनपुट (सिर्फ Enter) - प्रॉम्प्ट फिर से दिखाएं

---

## कोर वर्कफ़्लो फ्लैग

| फ्लैग / विकल्प       | शॉर्ट | विवरण                                                           |
| -------------------- | ----- | --------------------------------------------------------------- |
| `--add-all`          | `-a`  | कमिट करने से पहले सभी परिवर्तनों को स्टेज करें                  |
| `--group`            | `-g`  | स्टेज्ड परिवर्तनों को कई तार्किक कमिट्स में ग्रुप करें          |
| `--push`             | `-p`  | कमिट करने के बाद परिवर्तनों को रिमोट पर पुश करें                |
| `--yes`              | `-y`  | बिना प्रॉम्प्ट किए स्वचालित रूप से कमिट की पुष्टि करें          |
| `--dry-run`          |       | बिना कोई परिवर्तन किए होने वाला दिखाएं                          |
| `--no-verify`        |       | कमिट करते समय प्री-कमिट और लेफ्थुक हुक छोड़ें                   |
| `--skip-secret-scan` |       | स्टेज्ड परिवर्तनों में सीक्रेट्स के लिए सिक्योरिटी स्कैन छोड़ें |

**नोट:** सभी परिवर्तनों को पहले स्टेज करने के लिए `-a` और `-g` को जोड़ें (यानी, `-ag`), फिर उन्हें कमिट्स में ग्रुप करें।

**नोट:** `--group` का उपयोग करते समय, अधिकतम आउटपुट टोकन सीमा कमिट की जा रही फाइलों की संख्या के आधार पर स्वचालित रूप से स्केल की जाती है (1-9 फाइलों के लिए 2x, 10-19 फाइलों के लिए 3x, 20-29 फाइलों के लिए 4x, 30+ फाइलों के लिए 5x)। यह सुनिश्चित करता है कि LLM के पास सभी ग्रुप्ड कमिट्स को बिना कटौती के जेनरेट करने के लिए पर्याप्त टोकन हों, यहां तक कि बड़े चेंजसेट के लिए भी।

## मैसेज कस्टमाइज़ेशन

| फ्लैग / विकल्प      | शॉर्ट | विवरण                                                                   |
| ------------------- | ----- | ----------------------------------------------------------------------- |
| `--one-liner`       | `-o`  | एक लाइन का कमिट मैसेज जेनरेट करें                                       |
| `--verbose`         | `-v`  | प्रेरणा, आर्किटेक्चर, और इम्पैक्ट के साथ विस्तृत कमिट मैसेज जेनरेट करें |
| `--hint <text>`     | `-h`  | LLM को मार्गदर्शन देने के लिए एक हिंट जोड़ें                            |
| `--model <model>`   | `-m`  | इस कमिट के लिए उपयोग करने के लिए मॉडल निर्दिष्ट करें                    |
| `--language <lang>` | `-l`  | भाषा को ओवरराइड करें (नाम या कोड: 'Spanish', 'es', 'zh-CN', 'ja')       |
| `--scope`           | `-s`  | कमिट के लिए उपयुक्त स्कोप अनुमान लगाएं                                  |

**नोट:** आप पुष्टि प्रॉम्प्ट पर सिर्फ टाइपिंग करके इंटरैक्टिव रूप से फीडबैक प्रदान कर सकते हैं - 'r' के साथ प्रीफिक्स करने की आवश्यकता नहीं है। सिंपल रीरोल के लिए `r` टाइप करें, vi/emacs कीबाइंडिंग्स के साथ इन-प्लेस एडिट करने के लिए `e` टाइप करें, या `make it shorter` की तरह सीधे अपना फीडबैक टाइप करें।

## आउटपुट और वर्बोसिटी

| फ्लैग / विकल्प        | शॉर्ट | विवरण                                                               |
| --------------------- | ----- | ------------------------------------------------------------------- |
| `--quiet`             | `-q`  | गलतियों को छोड़कर सभी आउटपुट को दबाएं                               |
| `--log-level <level>` |       | लॉग स्तर सेट करें (debug, info, warning, error)                     |
| `--show-prompt`       |       | कमिट मैसेज जेनरेशन के लिए उपयोग किए गए LLM प्रॉम्प्ट को प्रिंट करें |

## हेल्प और वर्जन

| फ्लैग / विकल्प | शॉर्ट | विवरण                             |
| -------------- | ----- | --------------------------------- |
| `--version`    |       | gac वर्जन दिखाएं और बाहर निकलें   |
| `--help`       |       | हेल्प मैसेज दिखाएं और बाहर निकलें |

---

## उदाहरण वर्कफ़्लो

- **सभी परिवर्तनों को स्टेज करें और कमिट करें:**

  ```sh
  gac -a
  ```

- **एक कदम में कमिट और पुश करें:**

  ```sh
  gac -ap
  ```

- **एक लाइन का कमिट मैसेज जेनरेट करें:**

  ```sh
  gac -o
  ```

- **संरचित सेक्शन के साथ विस्तृत कमिट मैसेज जेनरेट करें:**

  ```sh
  gac -v
  ```

- **LLM के लिए एक हिंट जोड़ें:**

  ```sh
  gac -h "Refactor authentication logic"
  ```

- **कमिट के लिए स्कोप अनुमान लगाएं:**

  ```sh
  gac -s
  ```

- **स्टेज्ड परिवर्तनों को तार्किक कमिट्स में ग्रुप करें:**

  ```sh
  gac -g
  # केवल उन फाइलों को ग्रुप करता है जिन्हें आपने पहले से स्टेज किया है
  ```

- **सभी परिवर्तनों को ग्रुप करें (स्टेज्ड + अनस्टेज्ड) और ऑटो-कन्फर्म करें:**

  ```sh
  gac -agy
  # सब कुछ स्टेज करता है, इसे ग्रुप करता है, और ऑटो-कन्फर्म करता है
  ```

- **इस कमिट के लिए एक विशिष्ट मॉडल का उपयोग करें:**

  ```sh
  gac -m anthropic:claude-haiku-4-5
  ```

- **एक विशिष्ट भाषा में कमिट मैसेज जेनरेट करें:**

  ```sh
  # भाषा कोड का उपयोग करके (छोटा)
  gac -l zh-CN
  gac -l ja
  gac -l es

  # पूरे नामों का उपयोग करके
  gac -l "Simplified Chinese"
  gac -l Japanese
  gac -l Spanish
  ```

- **ड्राई रन (देखें कि क्या होगा):**

  ```sh
  gac --dry-run
  ```

## एडवांस्ड

- अधिक शक्तिशाली वर्कफ़्लो के लिए फ्लैग को जोड़ें (उदाहरण के लिए, `gac -ayp` स्टेज करने, ऑटो-कन्फर्म करने और पुश करने के लिए)
- LLM को भेजे गए प्रॉम्प्ट को डीबग या समीक्षा करने के लिए `--show-prompt` का उपयोग करें
- `--log-level` या `--quiet` के साथ वर्बोसिटी को एडजस्ट करें

### प्री-कमिट और लेफ्थुक हुक को छोड़ना

`--no-verify` फ्लैग आपको अपने प्रोजेक्ट में कॉन्फ़िगर किए गए किसी भी प्री-कमिट या लेफ्थुक हुक को छोड़ने की अनुमति देता है:

```sh
gac --no-verify  # सभी प्री-कमिट और लेफ्थुक हुक छोड़ें
```

**`--no-verify` का उपयोग कब करें:**

- प्री-कमिट या लेफ्थुक हुक अस्थायी रूप से विफल हो रहे हों
- समय लेने वाले हुक के साथ काम करते समय
- अभी तक सभी जांचों को पास न करने वाले काम-प्रगति कोड को कमिट करते समय

**नोट:** सावधानी से उपयोग करें क्योंकि ये हुक कोड गुणवत्ता मानकों को बनाए रखते हैं।

### सिक्योरिटी स्कैनिंग

gac में बिल्ट-इन सिक्योरिटी स्कैनिंग शामिल है जो स्वचालित रूप से आपके स्टेज्ड परिवर्तनों में संभावित सीक्रेट्स और API कुंजियों का पता लगाती है। यह गलती से संवेदनशील जानकारी कमिट करने से रोकने में मदद करता है।

**सिक्योरिटी स्कैन छोड़ना:**

```sh
gac --skip-secret-scan  # इस कमिट के लिए सिक्योरिटी स्कैन छोड़ें
```

**स्थायी रूप से अक्षम करने के लिए:** अपनी `.gac.env` फाइल में `GAC_SKIP_SECRET_SCAN=true` सेट करें।

**कब छोड़ें:**

- प्लेसहोल्डर कुंजियों के साथ उदाहरण कोड कमिट करते समय
- डमी क्रेडेंशियल्स वाले टेस्ट फिक्स्चर के साथ काम करते समय
- जब आपने सत्यापित कर लिया है कि परिवर्तन सुरक्षित हैं

**नोट:** स्कैनर सामान्य सीक्रेट फॉर्मेट का पता लगाने के लिए पैटर्न मिलान का उपयोग करता है। कमिट करने से पहले हमेशा अपने स्टेज्ड परिवर्तनों की समीक्षा करें।

## कॉन्फ़िगरेशन नोट्स

- gac को सेट अप करने की अनुशंसित विधि `gac init` चलाना और इंटरैक्टिव प्रॉम्प्ट का पालन करना है।
- पहले से कॉन्फ़िगर की गई भाषा है और सिर्फ प्रोवाइडर या मॉडल स्विच करने की जरूरत है? भाषा प्रश्नों के बिना सेटअप दोहराने के लिए `gac model` चलाएं।
- gac निम्नलिखित प्राथमिकता के क्रम में कॉन्फ़िगरेशन लोड करता है:
  1. CLI फ्लैग
  2. पर्यावरण चर
  3. प्रोजेक्ट-स्तर `.gac.env`
  4. यूज़र-स्तर `~/.gac.env`

### एडवांस्ड कॉन्फ़िगरेशन विकल्प

आप इन वैकल्पिक पर्यावरण चरों के साथ gac के व्यवहार को कस्टमाइज़ कर सकते हैं:

- `GAC_ALWAYS_INCLUDE_SCOPE=true` - कमिट मैसेज में स्वचालित रूप से स्कोप अनुमान लगाएं और शामिल करें (जैसे, `feat(auth):` बनाम `feat:`)
- `GAC_VERBOSE=true` - प्रेरणा, आर्किटेक्चर, और इम्पैक्ट सेक्शन के साथ विस्तृत कमिट मैसेज जेनरेट करें
- `GAC_TEMPERATURE=0.7` - LLM रचनात्मकता को नियंत्रित करें (0.0-1.0, कम = अधिक केंद्रित)
- `GAC_MAX_OUTPUT_TOKENS=4096` - जेनरेट किए गए मैसेज के लिए अधिकतम टोकन (`--group` का उपयोग करते समय फाइल काउंट के आधार पर स्वचालित रूप से 2-5x स्केल किया गया; उच्च या निम्न जाने के लिए ओवरराइड करें)
- `GAC_WARNING_LIMIT_TOKENS=4096` - जब प्रॉम्प्ट इस टोकन काउंट से अधिक हो जाएं तो चेतावनी दें
- `GAC_SYSTEM_PROMPT_PATH=/path/to/custom_prompt.txt` - कमिट मैसेज जेनरेशन के लिए कस्टम सिस्टम प्रॉम्प्ट का उपयोग करें
- `GAC_LANGUAGE=Spanish` - एक विशिष्ट भाषा में कमिट मैसेज जेनरेट करें (जैसे, Spanish, French, Japanese, German)। पूरे नाम या ISO कोड का समर्थन करता है (es, fr, ja, de, zh-CN)। इंटरैक्टिव चयन के लिए `gac language` का उपयोग करें
- `GAC_TRANSLATE_PREFIXES=true` - कन्वेंशनल कमिट प्रीफिक्सेस (feat, fix, आदि) को टारगेट भाषा में अनुवाद करें (डिफ़ॉल्ट: false, प्रीफिक्स को अंग्रेजी में रखता है)
- `GAC_SKIP_SECRET_SCAN=true` - स्टेज्ड परिवर्तनों में सीक्रेट्स के लिए स्वचालित सिक्योरिटी स्कैनिंग अक्षम करें (सावधानी से उपयोग करें)

पूर्ण कॉन्फ़िगरेशन टेम्प्लेट के लिए `.gac.env.example` देखें।

कस्टम सिस्टम प्रॉम्प्ट बनाने पर विस्तृत मार्गदर्शन के लिए, [docs/CUSTOM_SYSTEM_PROMPTS.md](docs/CUSTOM_SYSTEM_PROMPTS.md) देखें।

### कॉन्फ़िगरेशन सबकमांड्स

निम्नलिखित सबकमांड उपलब्ध हैं:

- `gac init` — प्रोवाइडर, मॉडल, और भाषा कॉन्फ़िगरेशन के लिए इंटरैक्टिव सेटअप विज़ार्ड
- `gac model` — भाषा प्रॉम्प्ट के बिना प्रोवाइडर/मॉडल/API कुंजी सेटअप (त्वरित स्विच के लिए आदर्श)
- `gac config show` — वर्तमान कॉन्फ़िगरेशन दिखाएं
- `gac config set KEY VALUE` — `$HOME/.gac.env` में एक कॉन्फ़िग कुंजी सेट करें
- `gac config get KEY` — एक कॉन्फ़िग मान प्राप्त करें
- `gac config unset KEY` — `$HOME/.gac.env` से एक कॉन्फ़िग कुंजी निकालें
- `gac language` (या `gac lang`) — कमिट मैसेज के लिए इंटरैक्टिव भाषा चयनकर्ता (GAC_LANGUAGE सेट करता है)
- `gac diff` — फ़िल्टर किए गए git डिफ़ दिखाएं स्टेज्ड/अनस्टेज्ड परिवर्तनों, रंग, और ट्रंकेशन के विकल्प के साथ

## मदद प्राप्त करना

- कस्टम सिस्टम प्रॉम्प्ट के लिए, [docs/CUSTOM_SYSTEM_PROMPTS.md](docs/CUSTOM_SYSTEM_PROMPTS.md) देखें
- ट्रबलशूटिंग और एडवांस्ड टिप्स के लिए, [docs/TROUBLESHOOTING.md](docs/TROUBLESHOOTING.md) देखें
- इंस्टॉलेशन और कॉन्फ़िगरेशन के लिए, [README.md#installation-and-configuration](README.md#installation-and-configuration) देखें
- योगदान करने के लिए, [docs/CONTRIBUTING.md](docs/CONTRIBUTING.md) देखें
- लाइसेंस जानकारी: [LICENSE](LICENSE)
