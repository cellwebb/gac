"""Prompt creation for GAC.

This module handles the creation of prompts for AI models, including template loading,
formatting, and integration with diff preprocessing.
"""

import logging
import os
import re
from pathlib import Path
from typing import Optional

from gac.errors import ConfigError
from gac.preprocess import preprocess_diff

logger = logging.getLogger(__name__)

# Maximum number of tokens to allocate for the diff in the prompt
DEFAULT_DIFF_TOKEN_LIMIT = 6000


def find_template_file() -> Optional[str]:
    """Find a prompt template file in standard locations.

    Searches for template files in the following order:
    1. Environment variable GAC_TEMPLATE_PATH
    2. Current directory: ./prompt.template
    3. User config directory: ~/.config/gac/prompt.template
    4. Package directory: gac/templates/default.prompt
    5. Project directory: prompts/default.prompt

    Returns:
        Path to the template file or None if not found
    """
    env_path = os.environ.get("GAC_TEMPLATE_PATH")
    if env_path and os.path.exists(env_path):
        return env_path

    current_dir_path = Path("./prompt.template")
    if current_dir_path.exists():
        return str(current_dir_path)

    config_dir_path = Path.home() / ".config" / "gac" / "prompt.template"
    if config_dir_path.exists():
        return str(config_dir_path)

    package_template = Path(__file__).parent / "templates" / "default.prompt"
    if package_template.exists():
        return str(package_template)

    default_template = Path(__file__).parent.parent.parent / "prompts" / "default.prompt"
    if default_template.exists():
        return str(default_template)

    return None


def load_prompt_template(template_path: Optional[str] = None) -> str:
    """Load the prompt template from a file or use the default embedded template.

    Args:
        template_path: Optional path to a template file

    Returns:
        Template content as string

    Raises:
        ConfigError: If no template file is found
    """
    if template_path:
        if os.path.exists(template_path):
            logger.debug(f"Loading prompt template from {template_path}")
            with open(template_path, "r") as f:
                return f.read()
        else:
            raise ConfigError(f"Prompt template file not found at {template_path}")

    template_file = find_template_file()
    if template_file:
        logger.debug(f"Loading prompt template from {template_file}")
        with open(template_file, "r") as f:
            return f.read()

    logger.error("No template file found and no default template defined.")
    raise ConfigError("No template file found and no default template defined.")


def build_prompt(
    status: str,
    diff: str,
    one_liner: bool = False,
    hint: str = "",
    template_path: Optional[str] = None,
    model: str = "anthropic:claude-3-haiku",
) -> str:
    """Build a prompt using a template file with XML-style tags.

    Args:
        status: Git status output
        diff: Git diff output
        one_liner: Whether to generate a single-line commit message
        hint: Additional context for the prompt
        template_path: Optional path to a template file
        model: Model identifier for token counting during preprocessing

    Returns:
        Formatted prompt string ready to be sent to an AI model
    """
    template = load_prompt_template(template_path)

    # Preprocess the diff with smart filtering and truncation
    logger.debug(f"Preprocessing diff ({len(diff)} characters)")
    processed_diff = preprocess_diff(diff, token_limit=DEFAULT_DIFF_TOKEN_LIMIT, model=model)
    logger.debug(f"Processed diff ({len(processed_diff)} characters)")

    # Replace placeholders with actual content
    template = template.replace("<status></status>", status)
    template = template.replace("<diff></diff>", processed_diff)
    template = template.replace("<hint></hint>", hint)

    # Process format options (one-liner vs multi-line)
    if one_liner:
        template = re.sub(r"<multi_line>.*?</multi_line>", "", template, flags=re.DOTALL)
        template = re.sub(r"<one_liner>(.*?)</one_liner>", r"\1", template, flags=re.DOTALL)
    else:
        template = re.sub(r"<one_liner>.*?</one_liner>", "", template, flags=re.DOTALL)
        template = re.sub(r"<multi_line>(.*?)</multi_line>", r"\1", template, flags=re.DOTALL)

    # Process hint section
    if not hint:
        template = re.sub(r"<hint_section>.*?</hint_section>", "", template, flags=re.DOTALL)
    else:
        template = re.sub(r"<hint_section>(.*?)</hint_section>", r"\1", template, flags=re.DOTALL)

    # Remove any remaining XML tags and clean up whitespace
    template = re.sub(r"<[^>]*>", "", template)
    template = re.sub(r"\n{3,}", "\n\n", template)

    return template.strip()


def clean_commit_message(message: str) -> str:
    """Clean up a commit message generated by an AI model.

    This function:
    1. Removes code block markers (```backticks```)
    2. Removes XML tags that might have leaked into the response
    3. Ensures the message starts with a conventional commit prefix

    Args:
        message: Raw commit message from AI

    Returns:
        Cleaned commit message ready for use
    """
    message = message.strip()

    # Remove code block markers (backticks)
    if message.startswith("```"):
        # Check if the first line contains a language identifier (e.g., ```python)
        if "\n" in message:
            first_line_end = message.find("\n")
            first_line = message[:first_line_end]
            if first_line.count("```") == 1:
                message = message[first_line_end + 1 :]
        else:
            message = message[3:].lstrip()

    if message.endswith("```"):
        message = message[:-3].rstrip()

    # Handle cases where message still has backticks
    message = message.replace("```\n", "").replace("\n```", "")

    # Remove any XML tags that might have leaked into the response
    for tag in ["<git-status>", "</git-status>", "<git-diff>", "</git-diff>"]:
        message = message.replace(tag, "")

    # Ensure message starts with a conventional commit prefix
    conventional_prefixes = [
        "feat:",
        "fix:",
        "docs:",
        "style:",
        "refactor:",
        "perf:",
        "test:",
        "build:",
        "ci:",
        "chore:",
    ]

    if not any(message.startswith(prefix) for prefix in conventional_prefixes):
        message = f"chore: {message}"

    return message.strip()
